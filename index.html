<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zscaler RDP/SSH Connectivity Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 1000px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .protocol-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .protocol-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .protocol-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .protocol-option.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .protocol-option input[type="radio"] {
            margin: 0;
        }

        .protocol-option label {
            cursor: pointer;
            font-weight: 500;
            margin: 0;
        }


        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .input-group input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .test-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 120px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .test-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results {
            margin-top: 30px;
        }

        .test-results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .test-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e1e5e9;
        }

        .test-item h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .test-item .status {
            font-size: 18px;
            font-weight: bold;
        }

        .test-item .status.success {
            color: #28a745;
        }

        .test-item .status.fail {
            color: #dc3545;
        }

        .test-item .status.timeout {
            color: #ffc107;
        }

        .test-item .status.error {
            color: #6c757d;
        }

        .test-item .status.pending {
            color: #007bff;
        }



        .zscaler-tag {
            background: #ff6b35;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 4px;
            display: inline-block;
        }

        .verbose-log {
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
            margin-top: 20px;
        }

        .log-header {
            background: #343a40;
            color: white;
            padding: 12px 16px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .log-controls {
            display: flex;
            gap: 8px;
        }

        .copy-log-btn, .toggle-log-btn {
            background: #495057;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .copy-log-btn:hover, .toggle-log-btn:hover {
            background: #6c757d;
        }

        .log-content {
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-content.collapsed {
            display: none;
        }

        .log-content pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            color: #333;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }

        .protocol-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }

        .protocol-info h4 {
            color: #1976d2;
            margin-bottom: 8px;
        }

        .protocol-info p {
            color: #424242;
            margin: 0;
            font-size: 14px;
        }

        .dns-info {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #2196f3;
        }

        .dns-info h4 {
            color: #1976d2;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .dns-explanation {
            background: #fff3cd;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
        }

        .dns-explanation p {
            margin: 0 0 8px 0;
            font-size: 13px;
            line-height: 1.4;
        }

        .dns-explanation p:last-child {
            margin-bottom: 0;
        }



        @media (max-width: 768px) {
            .test-results {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .test-item h3 {
                font-size: 12px;
            }
            
            .test-item .status {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîí Zscaler RDP/SSH Connectivity Tester</h1>
            <p>Test RDP/SSH server connectivity through Zscaler ZPA policies</p>
        </div>

        <div class="input-section">
            <div class="protocol-selection">
                <div class="protocol-option selected" id="rdpOption">
                    <input type="radio" id="rdp" name="protocol" value="rdp" checked>
                    <label for="rdp">üñ•Ô∏è Windows (RDP)</label>
                </div>
                <div class="protocol-option" id="sshOption">
                    <input type="radio" id="ssh" name="protocol" value="ssh">
                    <label for="ssh">üêß Linux (SSH)</label>
                </div>
            </div>


            <div class="protocol-info" id="protocolInfo">
                <h4>Windows RDP Testing</h4>
                <p>Tests port 3389 for Remote Desktop Protocol connectivity. Useful for Windows servers and workstations.</p>
            </div>

            <div class="dns-info">
                <h4>DNS Resolution</h4>
                <div class="dns-explanation">
                    <p><strong>Using Machine DNS Settings:</strong></p>
                    <p>This tool uses your browser's built-in DNS resolver, which automatically uses your machine's configured DNS servers. This ensures private domains are resolved correctly using your network's DNS settings.</p>
                    <p><strong>Note:</strong> Due to browser security restrictions, we cannot display the resolved IP address, only whether DNS resolution was successful or not.</p>
                </div>
            </div>

            <div class="input-group">
                <input type="text" id="domainInput" placeholder="Enter server domain (e.g., server.company.com)" />
                <button class="test-button" id="testButton" onclick="runTest()">Run Test</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Testing connectivity...</p>
        </div>

        <div class="results" id="results" style="display: none;">
            <div class="test-results">
                <div class="test-item">
                    <h3 id="servicePortLabel">RDP Port (3389)</h3>
                    <div class="status pending" id="wsStatus">Pending</div>
                </div>
                <div class="test-item">
                    <h3>Zscaler Verdict</h3>
                    <div class="status pending" id="verdictStatus">Pending</div>
                </div>
            </div>

            <div class="verbose-log" id="verboseLog" style="display: none;">
                <div class="log-header">
                    <h3>Verbose Debug Log</h3>
                    <div class="log-controls">
                        <button id="copyLogBtn" onclick="copyLogToClipboard()" class="copy-log-btn">üìã Copy Log</button>
                        <button id="toggleLogBtn" onclick="toggleLog()" class="toggle-log-btn">‚ñº Collapse</button>
                    </div>
                </div>
                <div class="log-content" id="logContent">
                    <pre id="logText">Debug information will appear here...</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        let testResults = {
            dns: null,
            ping: null,
            service: null,
            control: null
        };

        let debugLog = [];

        // Add log entry
        function addLogEntry(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logEntry = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            debugLog.push(logEntry);
            updateLogDisplay();
        }

        // Update log display
        function updateLogDisplay() {
            const logText = document.getElementById('logText');
            logText.textContent = debugLog.join('\n');
        }

        // Copy log to clipboard
        function copyLogToClipboard() {
            const logText = debugLog.join('\n');
            navigator.clipboard.writeText(logText).then(() => {
                const button = document.getElementById('copyLogBtn');
                const originalText = button.textContent;
                button.textContent = '‚úÖ Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy log:', err);
                alert('Failed to copy log to clipboard');
            });
        }

        // Toggle log visibility
        function toggleLog() {
            const logContent = document.getElementById('logContent');
            const toggleBtn = document.getElementById('toggleLogBtn');
            
            if (logContent.classList.contains('collapsed')) {
                logContent.classList.remove('collapsed');
                toggleBtn.textContent = '‚ñº Collapse';
            } else {
                logContent.classList.add('collapsed');
                toggleBtn.textContent = '‚ñ∂ Expand';
            }
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showResults(show) {
            document.getElementById('results').style.display = show ? 'block' : 'none';
        }

        function updateStatus(elementId, status, text) {
            const element = document.getElementById(elementId);
            element.textContent = text;
            element.className = `status ${status}`;
        }


        function updateProtocolInfo() {
            const rdpSelected = document.getElementById('rdp').checked;
            const protocolInfo = document.getElementById('protocolInfo');
            const servicePortLabel = document.getElementById('servicePortLabel');
            const domainInput = document.getElementById('domainInput');

            if (rdpSelected) {
                protocolInfo.innerHTML = `
                    <h4>Windows RDP Testing</h4>
                    <p>Tests port 3389 for Remote Desktop Protocol connectivity. Useful for Windows servers and workstations.</p>
                `;
                servicePortLabel.textContent = 'RDP Port (3389)';
                domainInput.placeholder = 'Enter Windows server domain (e.g., server.company.com)';
            } else {
                protocolInfo.innerHTML = `
                    <h4>Linux SSH Testing</h4>
                    <p>Tests port 22 for Secure Shell connectivity. Useful for Linux servers and Unix systems.</p>
                `;
                servicePortLabel.textContent = 'SSH Port (22)';
                domainInput.placeholder = 'Enter Linux server domain (e.g., server.company.com)';
            }
        }

        function updateProtocolSelection() {
            const rdpOption = document.getElementById('rdpOption');
            const sshOption = document.getElementById('sshOption');
            
            if (document.getElementById('rdp').checked) {
                rdpOption.classList.add('selected');
                sshOption.classList.remove('selected');
            } else {
                rdpOption.classList.remove('selected');
                sshOption.classList.add('selected');
            }
            
            updateProtocolInfo();
        }



        // Check if IP is within Zscaler's internal ranges
        function isZscalerInternalIP(ip) {
            // Zscaler's known IP ranges (simplified list of major ranges)
            const zscalerRanges = [
                // Americas ranges
                { network: '98.98.26.0', cidr: 23 },
                { network: '98.98.28.0', cidr: 24 },
                { network: '104.129.196.0', cidr: 22 },
                { network: '104.129.202.0', cidr: 23 },
                { network: '104.129.204.0', cidr: 22 },
                { network: '136.226.0.0', cidr: 22 },
                { network: '136.226.48.0', cidr: 20 },
                { network: '136.226.64.0', cidr: 20 },
                { network: '136.226.80.0', cidr: 21 },
                { network: '136.226.90.0', cidr: 23 },
                { network: '136.226.100.0', cidr: 22 },
                { network: '136.226.104.0', cidr: 21 },
                { network: '136.226.112.0', cidr: 22 },
                { network: '136.226.116.0', cidr: 23 },
                { network: '136.226.122.0', cidr: 23 },
                { network: '136.226.124.0', cidr: 22 },
                { network: '136.226.128.0', cidr: 21 },
                { network: '136.226.138.0', cidr: 23 },
                { network: '136.226.140.0', cidr: 23 },
                { network: '137.83.154.0', cidr: 24 },
                { network: '147.161.128.0', cidr: 23 },
                { network: '165.225.0.0', cidr: 23 },
                { network: '165.225.2.0', cidr: 24 },
                { network: '165.225.8.0', cidr: 22 },
                { network: '165.225.14.0', cidr: 23 },
                { network: '165.225.32.0', cidr: 21 },
                { network: '165.225.48.0', cidr: 24 },
                { network: '165.225.50.0', cidr: 23 },
                { network: '165.225.56.0', cidr: 21 },
                { network: '165.225.208.0', cidr: 20 },
                { network: '165.225.242.0', cidr: 23 },
                { network: '165.225.246.0', cidr: 23 },
                { network: '170.85.6.0', cidr: 23 },
                { network: '170.85.8.0', cidr: 21 },
                { network: '170.85.16.0', cidr: 21 },
                { network: '170.85.24.0', cidr: 22 },
                { network: '170.85.54.0', cidr: 23 },
                { network: '170.85.56.0', cidr: 23 },
                { network: '170.85.66.0', cidr: 23 },
                { network: '170.85.68.0', cidr: 22 },
                { network: '170.85.72.0', cidr: 22 },
                { network: '170.85.76.0', cidr: 23 },
                { network: '170.85.86.0', cidr: 23 },
                { network: '170.85.88.0', cidr: 21 },
                { network: '170.85.96.0', cidr: 20 },
                { network: '170.85.112.0', cidr: 22 },
                { network: '170.85.128.0', cidr: 21 },
                { network: '170.85.136.0', cidr: 22 },
                { network: '170.85.142.0', cidr: 23 },
                { network: '170.85.144.0', cidr: 21 },
                { network: '170.85.152.0', cidr: 22 },
                { network: '170.85.182.0', cidr: 23 },
                { network: '170.85.188.0', cidr: 22 },
                { network: '170.85.200.0', cidr: 21 },
                { network: '170.85.228.0', cidr: 22 }
            ];

            // Convert IP to number for comparison
            function ipToNumber(ip) {
                return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;
            }

            // Check if IP is in CIDR range
            function isInCIDR(ip, network, cidr) {
                const ipNum = ipToNumber(ip);
                const networkNum = ipToNumber(network);
                const mask = (0xffffffff << (32 - cidr)) >>> 0;
                return (ipNum & mask) === (networkNum & mask);
            }

            const ipNum = ipToNumber(ip);
            
            // Check against all Zscaler ranges
            for (const range of zscalerRanges) {
                if (isInCIDR(ip, range.network, range.cidr)) {
                    return true;
                }
            }
            
            return false;
        }

        // Test port connectivity using appropriate method based on port
        async function testServicePort(domain, port) {
            // For SSH port (22), use HTTP fetch since WebSocket won't work
            // For RDP port (3389), use WebSocket
            if (port === 22) {
                return await testPortWithHTTP(domain, port);
            } else {
                return await testPortWithWebSocket(domain, port);
            }
        }

        // Test port connectivity using HTTP fetch (for SSH)
        async function testPortWithHTTP(domain, port) {
            const url = `http://${domain}:${port}/`;
            const start = performance.now();
            
            try {
                addLogEntry(`Testing port ${port} connectivity using HTTP fetch (SSH port)`);
                addLogEntry(`Attempting HTTP fetch to ${url} (expecting protocol mismatch)`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(url, { 
                    mode: "no-cors",
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                const elapsed = performance.now() - start;
                
                // If we get here, TCP connection succeeded (even if protocol mismatch)
                addLogEntry(`HTTP fetch completed after ${elapsed.toFixed(2)}ms - TCP connection to port ${port} succeeded`, 'success');
                addLogEntry(`Response type: ${response.type}, status: ${response.status}`, 'info');
                
                return {
                    success: true,
                    message: `Port ${port} is accessible (TCP connection succeeded)`,
                    timing: elapsed,
                    method: 'http_fetch'
                };
                
            } catch (error) {
                const elapsed = performance.now() - start;
                
                addLogEntry(`HTTP fetch error after ${elapsed.toFixed(2)}ms: ${error.name} - ${error.message}`, 'error');
                
                if (error.name === 'AbortError') {
                    addLogEntry(`HTTP fetch timed out after ${elapsed.toFixed(2)}ms - Zscaler is blocking this port`, 'warning');
                    return {
                        success: false,
                        error: 'timeout',
                        message: `Port ${port} timed out - Zscaler is blocking this port`,
                        timing: elapsed,
                        method: 'http_fetch'
                    };
                } else if (error.message.includes('Failed to fetch') || 
                          error.message.includes('NetworkError') ||
                          error.message.includes('ERR_CONNECTION_REFUSED') ||
                          error.message.includes('ERR_CONNECTION_RESET') ||
                          error.message.includes('ERR_CONNECTION_ABORTED')) {
                    addLogEntry(`HTTP fetch connection failed after ${elapsed.toFixed(2)}ms - Zscaler allows connection but service not running`, 'info');
                    return {
                        success: false,
                        error: 'connection_refused',
                        message: `Port ${port} connection refused - Zscaler allows connection but service not running`,
                        timing: elapsed,
                        method: 'http_fetch'
                    };
                } else {
                    addLogEntry(`HTTP fetch unknown error after ${elapsed.toFixed(2)}ms: ${error.message}`, 'error');
                    return {
                        success: false,
                        error: 'unknown',
                        message: `Port ${port} test failed: ${error.message}`,
                        timing: elapsed,
                        method: 'http_fetch'
                    };
                }
            }
        }

        // Test port connectivity using WebSocket (for RDP)
        async function testPortWithWebSocket(domain, port) {
            return new Promise((resolve) => {
                addLogEntry(`Testing port ${port} connectivity using WebSocket (RDP port)`);
                addLogEntry(`Attempting WebSocket connection to wss://${domain}:${port}`);
                
                const start = performance.now();
                let resolved = false;
                
                const ws = new WebSocket(`wss://${domain}:${port}`);
                
                // Set a timeout for the entire connection attempt
                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        const elapsed = performance.now() - start;
                        addLogEntry(`WebSocket connection timed out after ${elapsed.toFixed(2)}ms - Zscaler is blocking this port`, 'warning');
                        ws.close();
                        resolve({ 
                            success: false, 
                            error: 'timeout',
                            message: `Port ${port} timed out - Zscaler is blocking this port`,
                            timing: elapsed,
                            method: 'websocket'
                        });
                    }
                }, 5000);

                ws.onopen = () => {
                    if (!resolved) {
                        resolved = true;
                        const elapsed = performance.now() - start;
                        addLogEntry(`WebSocket connection successful after ${elapsed.toFixed(2)}ms - port ${port} is accessible`, 'success');
                        clearTimeout(timeout);
                        ws.close();
                        resolve({ 
                            success: true, 
                            message: `Port ${port} is accessible`,
                            timing: elapsed,
                            method: 'websocket'
                        });
                    }
                };

                ws.onerror = (error) => {
                    if (!resolved) {
                        resolved = true;
                        const elapsed = performance.now() - start;
                        addLogEntry(`WebSocket connection refused after ${elapsed.toFixed(2)}ms - Zscaler allows connection but service not running`, 'info');
                        clearTimeout(timeout);
                        resolve({ 
                            success: false, 
                            error: 'connection_refused',
                            message: `Port ${port} connection refused - Zscaler allows connection but service not running`,
                            timing: elapsed,
                            method: 'websocket'
                        });
                    }
                };

                ws.onclose = (event) => {
                    if (!resolved) {
                        resolved = true;
                        const elapsed = performance.now() - start;
                        addLogEntry(`WebSocket connection closed with code ${event.code} after ${elapsed.toFixed(2)}ms`, 'info');
                        clearTimeout(timeout);
                        resolve({ 
                            success: false, 
                            error: 'connection_refused',
                            message: `Port ${port} connection refused - Zscaler allows connection but service not running`,
                            timing: elapsed,
                            method: 'websocket'
                        });
                    }
                };
            });
        }




        async function runTest() {
            const domain = document.getElementById('domainInput').value.trim();
            const protocol = document.querySelector('input[name="protocol"]:checked').value;
            
            if (!domain) {
                alert('Please enter a domain name');
                return;
            }

            // Reset UI
            showLoading(true);
            showResults(false);
            document.getElementById('testButton').disabled = true;

            // Reset debug log
            debugLog = [];
            addLogEntry(`Starting ${protocol.toUpperCase()} connectivity test for domain: ${domain}`);
            addLogEntry(`Using browser's built-in DNS resolver (machine DNS settings)`);

            // Reset status indicators
            updateStatus('wsStatus', 'pending', 'Testing...');
            updateStatus('verdictStatus', 'pending', 'Testing...');

            try {
                // Test port connectivity using WebSocket
                const servicePort = protocol === 'ssh' ? 22 : 3389;
                addLogEntry(`Testing ${protocol.toUpperCase()} port ${servicePort} connectivity using WebSocket`);
                
                const serviceResult = await testServicePort(domain, servicePort);
                
                // Log detailed results
                addLogEntry(`=== WEB SOCKET TEST RESULTS ===`, 'info');
                addLogEntry(`Status: ${serviceResult.success ? 'SUCCESS' : 'FAILED'}`, serviceResult.success ? 'success' : 'error');
                addLogEntry(`Timing: ${serviceResult.timing.toFixed(2)}ms`, 'info');
                addLogEntry(`Message: ${serviceResult.message}`, 'info');
                if (serviceResult.error) {
                    addLogEntry(`Error Type: ${serviceResult.error}`, 'error');
                }
                
                if (serviceResult.success) {
                    addLogEntry(`${protocol.toUpperCase()} port ${servicePort} is accessible`);
                    updateStatus('wsStatus', 'success', 'Connected');
                } else if (serviceResult.error === 'timeout') {
                    addLogEntry(`${protocol.toUpperCase()} port ${servicePort} timed out - Zscaler is blocking this port`, 'warning');
                    updateStatus('wsStatus', 'timeout', 'Timeout');
                } else if (serviceResult.error === 'connection_refused') {
                    addLogEntry(`${protocol.toUpperCase()} port ${servicePort} connection refused - service not running`, 'info');
                    updateStatus('wsStatus', 'error', 'Refused');
                } else {
                    addLogEntry(`${protocol.toUpperCase()} port ${servicePort} test failed: ${serviceResult.error}`, 'error');
                    updateStatus('wsStatus', 'fail', 'Failed');
                }

                // Determine Zscaler approval based on WebSocket results
                // Timeout = Zscaler doesn't approve (blocked)
                // Refused = Zscaler approves (allows connection, service not running)
                const isApproved = serviceResult.error === 'connection_refused';
                
                if (isApproved) {
                    addLogEntry(`‚úÖ Zscaler Approved: Port connection refused (Zscaler allows connection, service not running)`, 'success');
                    updateStatus('verdictStatus', 'success', 'üëç Zscaler Approved');
                } else if (serviceResult.success) {
                    addLogEntry(`‚úÖ Zscaler Approved: Port is accessible`, 'success');
                    updateStatus('verdictStatus', 'success', 'üëç Zscaler Approved');
                } else {
                    addLogEntry(`‚ùå Zscaler Not Approved: Port timed out (Zscaler is blocking this port)`, 'error');
                    updateStatus('verdictStatus', 'fail', 'üëé Zscaler Not Approved');
                }

                addLogEntry(`Test completed. Final result: ${isApproved ? 'APPROVED' : 'NOT APPROVED'}`);
                showResults(true);
                document.getElementById('verboseLog').style.display = 'block';

            } catch (error) {
                addLogEntry(`Test failed with error: ${error.message}`, 'error');
                addLogEntry(`Stack trace: ${error.stack}`, 'error');
                console.error('Test failed:', error);
                
                document.getElementById('results').innerHTML = `
                    <div class="error">
                        <h3>Test Failed</h3>
                        <p>An error occurred during testing: ${error.message}</p>
                    </div>
                `;
                showResults(true);
                document.getElementById('verboseLog').style.display = 'block';
            } finally {
                showLoading(false);
                document.getElementById('testButton').disabled = false;
            }
        }

        // Event listeners
        document.getElementById('rdp').addEventListener('change', updateProtocolSelection);
        document.getElementById('ssh').addEventListener('change', updateProtocolSelection);

        // Allow Enter key to trigger test
        document.getElementById('domainInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                runTest();
            }
        });

        // Initialize
        updateProtocolSelection();
    </script>
</body>
</html>
